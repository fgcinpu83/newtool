import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { AppGateway } from '../gateway.module';
import { NormalizationService } from '../normalization/normalization.service';
import { RedisService } from '../shared/redis.service';
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

interface MatchEntry {
    matchId: string;
    globalId?: string; // üõ°Ô∏è v8.0: Master ID mapping for paired matches
    provider: 'A' | 'B';
    home: string;
    away: string;
    league: string;
    time?: number;
    rawId: string;
    lastSeen: number;
}

export type BindingState = 'VERIFIED' | 'POTENTIAL' | 'DEGRADED' | 'EXPIRED';

interface ConfirmedPair {
    globalId: string;
    matchA: MatchEntry;
    matchB: MatchEntry;
    score: number;
    foundAt: number;
    lastVerifiedAt: number;
    state: BindingState;
}

@Injectable()
export class DiscoveryService implements OnModuleInit {
    private readonly logger = new Logger(DiscoveryService.name);

    private registryA = new Map<string, MatchEntry>();
    private registryB = new Map<string, MatchEntry>();
    private confirmedPairs = new Map<string, ConfirmedPair>();
    private eventLookup = new Map<string, Set<string>>();
    private marketPool = new Map<string, any[]>();
    private providerMetrics = new Map<string, { lastIngestion: number, eventCount: number }>();
    private updateCounts = { A: 0, B: 0 };

    private sampleLoggedB = false;
    private bypassAllFilters = false; // üõ°Ô∏è v7.4.3: REACTIVE FILTERS (Disabled bypass)

    // üõ°Ô∏è v7.4 OIPM (Odds Ingestion Per Minute)
    private oipmCounts = { A: 0, B: 0 };
    private wireLog = path.join(process.cwd(), 'logs', 'wire_debug.log');

    // üõ°Ô∏è v4.0 AUTO-REFRESH STATE
    private lowEventsBCounter = 0;

    // üõ°Ô∏è v5.2 PASSIVE OBSERVER MODE - No auto-clicks
    private readonly PASSIVE_MODE_UNTIL = 1800000000000; // üõ°Ô∏è Extended to 2027 to ensure manual control

    // üõ°Ô∏è v5.2 SCANNER PRIORITY MODE - Activated when B > 20
    private scannerPriorityActive = false;
    private lastPriorityBroadcast = 0;

    // üõ°Ô∏è v5.2 REGISTRY WARM-UP - Pre-allocate for large data
    private registryBWarmup = false;

    // üõ°Ô∏è v3.7 LOCAL ORDER BOOK (LOB) CONFIG
    private readonly LOB_TTL_MS = 120000; // üõ°Ô∏è v8.8: Safer TTL for EVENT_DRIVEN providers (AFB88)
    private readonly CLEANUP_INTERVAL_MS = 5000;

    constructor(
        private gateway: AppGateway,
        private normalization: NormalizationService,
        private redis: RedisService
    ) { }

    onModuleInit() {
        this.logger.log('üõ°Ô∏è LOB-STATE-ENGINE v3.7: Active Ghost Match Elimination');
        this.bypassAllFilters = false;

        this.clearAllMemory();

        const logDir = path.join(process.cwd(), 'logs');
        if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true });

        // üöÄ HEARTBEAT CLEANUP (Logika Pendeteksian Ghost Match)
        setInterval(() => this.cleanRegistry(), this.CLEANUP_INTERVAL_MS);

        this.logger.log(`[LOB-ENGINE] ‚úÖ Heartbeat Cleanup Enabled (TTL: ${this.LOB_TTL_MS / 1000}s)`);
        setInterval(() => this.printStabilityReport(), 2000);

        // üõ°Ô∏è v7.5 Flow Transparency Trace (Every 10 seconds)
        setInterval(() => {
            const flowMsg = `[v7.5] FLOW-TRACE: A=${this.oipmCounts.A} B=${this.oipmCounts.B} | RegA=${this.registryA.size} RegB=${this.registryB.size} | Pairs=${this.confirmedPairs.size}`;
            console.log(`%c${flowMsg}`, 'color:#0ff');
            this.logToDisk(flowMsg);
        }, 10000);

        // üî• v3.5.7 Socket Pipe Fix: Broadcast raw MATCH_LIST every 1s
        setInterval(() => this.broadcastRawMatches(), 1000);

        // üõ°Ô∏è v5.2 WARM-UP Registry B for large data ingestion
        this.warmupRegistryB();
        this.logToDisk('DiscoveryService Initialized (v5.2 Final Sync Ready)');
        this.logger.log('üõ°Ô∏è v5.2 PASSIVE MODE: Auto-navigation DISABLED. Waiting for manual navigation.');

        // üî• v6.3: Periodic Recheck for Orphans (Every 5 seconds)
        setInterval(() => this.recheckOrphanedMatches(), 5000);

        // üõ°Ô∏è v7.4 OIPM Proof of Flow (Every 60 seconds)
        setInterval(() => {
            if (this.oipmCounts.A > 0 || this.oipmCounts.B > 0) {
                const oipmLog = `[OIPM] üõ°Ô∏è Aliran Data Mentah: A=${this.oipmCounts.A} pkts/min | B=${this.oipmCounts.B} pkts/min`;
                console.log(`%c${oipmLog}`, 'background:#004d40;color:#fff;font-weight:bold');
                this.logToDisk(oipmLog);
                // üõ°Ô∏è v7.5 Dashboard Sync
                this.gateway.sendUpdate('metrics:oipm', { A: this.oipmCounts.A, B: this.oipmCounts.B });
                this.oipmCounts = { A: 0, B: 0 };
            }
        }, 60000);
    }

    public clearAllMemory() {
        this.logger.warn('üö® [DISCOVERY] Wiping all registries (EMERGENCY BUFFER FLUSH)');
        this.registryA.clear();
        this.registryB.clear();
        this.confirmedPairs.clear();
        this.eventLookup.clear();
        this.marketPool.clear();
        this.updateCounts = { A: 0, B: 0 };
    }

    public flushRegistryB() {
        this.logger.warn('üö® [DISCOVERY] Flushing Registry B (Garbage Purge)');
        this.registryB.clear();
        // Remove pairs involving B
        for (const [id, pair] of this.confirmedPairs.entries()) {
            if (pair.matchB.provider === 'B') {
                this.confirmedPairs.delete(id);
            }
        }
        this.gateway.sendUpdate('system_log', { level: 'info', message: 'üßπ Registry B Flushed: Garbage data purged.' });
    }

    /**
     * üõ°Ô∏è v5.2 WARM-UP Registry B for Large Data Ingestion
     * Pre-allocates capacity and sets flags to prevent stale data protection
     */
    private warmupRegistryB() {
        this.logger.log('üî• [WARM-UP] Preparing Registry B for large data (500+ events)');
        this.registryBWarmup = true;
        this.bypassAllFilters = false; // üõ°Ô∏è v7.6: Do NOT bypass filters during warm-up!

        // Disable stale data protection for B temporarily
        this.gateway.sendUpdate('system_log', {
            level: 'info',
            message: 'üî• Registry B WARM-UP: Ready to receive 500+ events. Stale protection DISABLED.'
        });

        this.logger.log('‚úÖ [WARM-UP] Registry B is now ready for heavy data load');
    }

    /**
     * üõ°Ô∏è v5.2 SCANNER PRIORITY - Shift CPU to arbitrage engine when B > 20
     */
    private checkScannerPriority(countB: number) {
        const now = Date.now();

        if (countB >= 20 && !this.scannerPriorityActive) {
            this.scannerPriorityActive = true;
            this.logger.log('üöÄ [SCANNER-PRIORITY] Events B >= 20! Activating arbitrage engine priority.');
            this.gateway.sendUpdate('system_log', {
                level: 'info',
                message: `üöÄ SCANNER PRIORITY ACTIVE: Events B = ${countB}. Arbitrage engine is now prioritized!`
            });

            // Broadcast pairing opportunity
            this.gateway.sendUpdate('scanner:priority', {
                status: 'HIGH_DATA_FLOW',
                active_match_count: this.registryB.size
            });
        }

        // Log scanner priority every 5 seconds when active
        if (this.scannerPriorityActive && (now - this.lastPriorityBroadcast) > 5000) {
            this.lastPriorityBroadcast = now;
            const countA = this.registryA.size;
            const pairsCount = this.confirmedPairs.size;

            console.log(`[SCANNER-PRIORITY] üìä A:${countA} B:${countB} Pairs:${pairsCount} (Priority Mode ACTIVE)`);

            // Force broadcast all confirmed pairs to scanner
            for (const pair of this.confirmedPairs.values()) {
                this.broadcastPairing(pair.globalId);
            }
        }
    }

    private broadcastRawMatches() {
        if (this.registryA.size === 0 && this.registryB.size === 0) return;

        const rawFeed = {
            A: Array.from(this.registryA.values()).slice(0, 50), // Limit payload
            B: Array.from(this.registryB.values()).slice(0, 50),
            timestamp: Date.now()
        };
        this.gateway.sendUpdate('scanner:raw_feed', rawFeed);
    }

    public resolveGlobalEventId(account: string, rawId: string): string[] {
        // üõ°Ô∏è v8.5 [STRICT]: Fail-Fast Identity Resolution (No more synthetic aliases)
        const key = `${account}:${rawId}`;
        const set = this.eventLookup.get(key);

        if (!set || set.size === 0) {
            throw new Error(`Identity Resolution Failed: No Global ID found for provider event ${key}`);
        }

        return Array.from(set);
    }

    public async registerMatch(account: 'A' | 'B', subProvider: string, rawData: any) {
        if (account === 'A' || account === 'B') {
            this.updateCounts[account]++;
            this.oipmCounts[account]++; // üõ°Ô∏è v7.4 OIPM Tracking
        }

        // üõ°Ô∏è v3.5.1 EMERGENCY: Ultra-aggressive team extraction
        let home = String(rawData.HomeName || rawData.home || rawData.h || rawData.Home || rawData.H ||
            rawData.ht || rawData.HT || rawData.HomeTeam || rawData.hTeam ||
            rawData.hname || rawData.h_name || rawData.htnm || rawData.homeTeam ||
            rawData.team1 || rawData.Team1 || rawData.TeamHome || '').trim();
        let away = String(rawData.AwayName || rawData.away || rawData.a || rawData.Away || rawData.A ||
            rawData.at || rawData.AT || rawData.AwayTeam || rawData.aTeam ||
            rawData.awayname || rawData.a_name || rawData.atnm || rawData.awayTeam ||
            rawData.team2 || rawData.Team2 || rawData.TeamAway || '').trim();
        // üõ°Ô∏è v7.1: Support combined 'match' field (OpticOdds style)
        if ((!home || !away) && typeof rawData.match === 'string' && rawData.match.includes(' vs ')) {
            const parts = rawData.match.split(' vs ');
            home = parts[0].trim();
            away = parts[1].trim();
        }

        if (!home || !away) {
            // this.logger.debug(`[STABILITY-REJECT] Missing teams for ${account}:${subProvider}`);
            return;
        }

        // üõ°Ô∏è v8.2 ID GUARD: Detect and bypass "dummy" IDs from buggy sniffers (e.g. "0.6", "0.8")
        let rawMatchId = String(rawData.Matchid || rawData.matchId || rawData.id || '');
        const isDummyId = !rawMatchId || rawMatchId.length < 3 || /^\d+\.\d+$/.test(rawMatchId) || rawMatchId === '0';

        const hFinger = this.normalization.generateTeamFingerprint(home);
        const aFinger = this.normalization.generateTeamFingerprint(away);
        const globalFingerprint = [hFinger, aFinger].sort().join('::');

        if (isDummyId) {
            rawMatchId = globalFingerprint; // Use fingerprint as ID if provider sends junk IDs
        }

        const league = String(rawData.LeagueName || rawData.league || rawData.League || rawData.CompetitionName || 'Unknown').trim();
        const docTitle = String(rawData.title || '').toLowerCase(); // üõ°Ô∏è v7.4 title hint

        // üõ°Ô∏è v7.4 CLIENT ISOLATION
        const clientId = rawData.clientId || 'default';
        const instanceKey = `${account}:${clientId}`;

        // üõ°Ô∏è v4.7 TOTAL VISIBILITY: Log every single match attempted
        const traceMsg = `[STABILITY-TRACE] Account=${account} CID=${clientId} SubProvider=${subProvider} Home=${home} Away=${away} ID=${rawMatchId}`;
        console.log(traceMsg);
        try { fs.appendFileSync(this.wireLog, `[${new Date().toISOString()}] ${traceMsg}\n`); } catch (e) { }

        if (account === 'B' && !this.sampleLoggedB) {
            const sample = JSON.stringify(rawData).substring(0, 300);
            console.log(`[PAYLOAD-AUDIT-B] üõ∞Ô∏è SAMPLE: ${sample}`);
            this.logToDisk(`[PAYLOAD-AUDIT-B] ${sample}`);
            this.sampleLoggedB = true;
        }

        // üõ°Ô∏è v3.4: ACCOUNT A - Apply virtual filter (loosened)
        if (account === 'A' || account === 'B') {
            const leagueL = league.toLowerCase();
            const homeL = home.toLowerCase();
            const awayL = away.toLowerCase();

            // üõ°Ô∏è v7.4.2 ULTRA-STRICT VIRTUAL GATE (Modifikasi: e- diizinkan untuk audit) (Modifikasi: e- diizinkan untuk audit)
            const virtualSoccerRegex = /(\s\[V\]$|\(V\)|\[BULLFROG\]|BULLFROG|FIFA\s\d|VOLTA)/i;
            const junkPatterns = [
                'virtual', 'simulated', '[v]', '(v)', 'fifa 23', 'fifa 24', 'nba2k', 'esim', 'cyber',
                'srl', 'e-soccer', 'penalty', 'instant', 'winning goal', 'e-liverpool', 'bullfrog'
            ];
            const timePattern = /\b\d{1,2}:\d{2}\s*(?:AM|PM)?\b/i; // Matches 08:12PM, 12:30

            // üõ°Ô∏è v8.9: HEURISTIC VIRTUAL GATE (Fail-Open for Account B)
            const isVirtual = virtualSoccerRegex.test(home) || virtualSoccerRegex.test(away) || virtualSoccerRegex.test(league) ||
                virtualSoccerRegex.test(homeL) || virtualSoccerRegex.test(awayL) ||
                junkPatterns.some(p => leagueL.includes(p) || homeL.includes(p) || awayL.includes(p)) ||
                timePattern.test(home) || timePattern.test(away);

            if (isVirtual && !this.bypassAllFilters) {
                // üöÄ FAIL-OPEN: If it's Account B, we allow it even if it looks virtual, unless it's VERY obviously junk
                if (account === 'B') {
                    const isExtremeJunk = leagueL.includes('virtual') && (homeL.includes('fifa') || awayL.includes('fifa'));
                    if (!isExtremeJunk) {
                        this.logToDisk(`[HEURISTIC-ACCEPT] Account B: Allowing potential virtual/labeled match: ${home} vs ${away}`);
                    } else {
                        const rejMsg = `[VIRTUAL-REJECT] Account B (Hard): ${home} vs ${away} Reason=extreme_virtual`;
                        console.log(rejMsg);
                        return;
                    }
                } else {
                    const rejMsg = `[VIRTUAL-REJECT] Account=${account} Home=${home} Away=${away} Reason=virtual_regex`;
                    console.log(rejMsg);
                    return;
                }
            }

            // üõ°Ô∏è v8.8: Removed strict isSportsContext check to prevent Catch-22 with junk filters
        }
        // üõ°Ô∏è v4.7: Bypass all filters to ensure data makes it to registry
        if (this.bypassAllFilters) {
            this.logToDisk(`[BYPASS-INGEST] ${account} | ${home} vs ${away}`);
            // Force valid for bypass mode
        } else {
            // üõ°Ô∏è v3.5.5 STRICT VALIDATION GATE
            const validation = this.isRealEvent(rawData, account);
            if (!validation.valid && !this.bypassAllFilters) {
                const rejMsg = `[VALIDATION-REJECT] Account=${account} Home=${home} Away=${away} Reason=${validation.reason}`;
                console.log(rejMsg);
                return;
            }
            if (validation.canonical) {
                home = validation.canonical.home;
                away = validation.canonical.away;
            }
        }

        if (account === 'B' && !this.sampleLoggedB) {
            const sample = JSON.stringify(rawData).substring(0, 300);
            console.log(`[PAYLOAD-AUDIT-B] üõ∞Ô∏è SAMPLE: ${sample}`);
            this.logToDisk(`[PAYLOAD-AUDIT-B] ${sample}`);
            this.sampleLoggedB = true;
        }

        // üõ°Ô∏è v4.5: Emergency Filter Bypass (Length check disabled)
        /*
        if (!home || !away || home.length < 2 || away.length < 2) {
            if (account === 'A') {
                console.log(`[DISCOVERY-A-REJECT] Missing team names or too short: home="${home}" away="${away}" league="${league}"`);
            }
            return;
        }
        */

        const registry = account === 'A' ? this.registryA : this.registryB;
        const otherRegistry = account === 'A' ? this.registryB : this.registryA;

        // Moved Up
        // const hFinger = this.normalization.generateTeamFingerprint(home);
        // ...

        if (account === 'A') {
            const traceMsgA = `[DISCOVERY-A-TRACE] Attemping register: [${home}] vs [${away}] League=[${league}] Fingerprint=[${globalFingerprint}]`;
            console.log(traceMsgA);
            try { fs.appendFileSync(this.wireLog, `[${new Date().toISOString()}] ${traceMsgA}\n`); } catch (e) { }
            if (!hFinger || !aFinger) {
                console.log(`[DISCOVERY-A-REJECT] Empty fingerprint: hFinger="${hFinger}" aFinger="${aFinger}"`);
                return;
            }
        }

        const entry: MatchEntry = {
            matchId: globalFingerprint,
            provider: account,
            home: home,
            away: away,
            league: String(rawData.LeagueName || rawData.league || 'Unknown'),
            rawId: rawMatchId,
            lastSeen: Date.now()
        };

        // v3.4 STORAGE CONFIRMED (only for real matches)
        if (account === 'A') {
            const isNew = !registry.has(globalFingerprint);
            console.log(`[STORAGE-OK-A] Registered ${isNew ? 'NEW ' : 'EXISTING '}match: ${home} vs ${away} (Total RegA: ${registry.size + (isNew ? 1 : 0)})`);
        }
        this.logToDisk(`[STORAGE-OK] ${account}:${subProvider} ${home} vs ${away}`);

        // v3.2 MEGA-TRACE
        if (account === 'B') {
            try { this.logToDisk(`[MEGA-TRACE-B] EntryReady rawId=${entry.rawId} fingerprint=${globalFingerprint.substring(0, 10)}`); } catch (e) { }
        }

        registry.set(globalFingerprint, entry);

        // [v3.2] Forced Log for Account B
        if (account === 'B') {
            const bMsg = `[DISCOVERY-B-OK] MapKey=${globalFingerprint} Teams=${entry.home} vs ${entry.away}`;
            this.logToDisk(bMsg);
            console.log(bMsg);
        } else {
            const aMsg = `[DISCOVERY-A-OK] MapKey=${globalFingerprint} Teams=${entry.home} vs ${entry.away}`;
            this.logToDisk(aMsg);
        }

        // üõ°Ô∏è v8.1: Redis SETNX Lock (Prevent Double Processing)
        const lockKey = `lock:match:${account}:${entry.rawId}`;
        const locked = await this.redis.getClient().set(lockKey, '1', 'PX', 5000, 'NX'); // 5s lock to prevent race conditions
        if (!locked) {
            // this.logger.debug(`[DEDUPE] Match ${entry.rawId} already being processed.`);
            return;
        }

        const lookupKey = `${account}:${entry.rawId}`;
        if (!this.eventLookup.has(lookupKey)) this.eventLookup.set(lookupKey, new Set());
        this.eventLookup.get(lookupKey)!.add(globalFingerprint);

        let partner = otherRegistry.get(globalFingerprint);
        let pairScore = 1.0;

        // üõ°Ô∏è v6.3 SYMMETRIC PAIRING - Both A and B search for partners
        if (!partner && otherRegistry.size > 0) {
            const candidates: { other: MatchEntry, teamScore: number, leagueScore: number }[] = [];
            // üõ°Ô∏è v7.9.5: AUDIT MODE - Always log best matches for B to debug bottleneck
            let bestScore = 0;
            let bestMatch: MatchEntry | null = null;

            for (const [otherFinger, otherEntry] of otherRegistry.entries()) {
                const teamSimilarity = this.normalization.getSimilarity(`${entry.home} ${entry.away}`, `${otherEntry.home} ${otherEntry.away}`);
                const leagueSimilarity = this.normalization.getSimilarity(this.normalization.normalizeLeague(entry.league), this.normalization.normalizeLeague(otherEntry.league));

                if (teamSimilarity > bestScore) {
                    bestScore = teamSimilarity;
                    bestMatch = otherEntry;
                }

                candidates.push({ other: otherEntry, teamScore: teamSimilarity, leagueScore: leagueSimilarity });
            }

            if (account === 'B') {
                const auditMsg = `[PAIR-AUDIT] B:[${entry.home} vs ${entry.away}] -> Best A:[${bestMatch ? bestMatch.home + ' vs ' + bestMatch.away : 'NONE'}] Score=${bestScore.toFixed(4)}`;
                console.log(auditMsg);
                if (bestScore > 0.3) { // Only log to disk if somewhat relevant
                    this.logToDisk(auditMsg);
                }
            }

            // Sort by best team score
            candidates.sort((a, b) => b.teamScore - a.teamScore);

            // üî¥ [PAIR-AUDIT] Log top 5 attempts for every B match to debug bottleneck
            const top5 = candidates.slice(0, 5);
            console.log(`%c[PAIR-TRACE] üõ∞Ô∏è Account B Match Trace: [${entry.home} vs ${entry.away}]`, 'background:#333;color:#fff;font-weight:bold');
            console.log(`  [PAIR-TRACE] Registry A Status: size=${otherRegistry.size} | League: ${entry.league}`);

            top5.forEach((c, i) => {
                const isMatch = c.teamScore >= 0.55;
                const status = isMatch ? '‚úÖ' : '‚ùå';
                console.log(`  [PAIR-LOG] ${status} #${i + 1}: [${c.other.home} vs ${c.other.away}] (League: ${c.other.league}) | TeamScore: ${c.teamScore.toFixed(3)} | LScore: ${c.leagueScore.toFixed(3)}`);
            });

            // üõ°Ô∏è v7.1 TIERED MATCHING SYSTEM with Base/Quote Validation
            const AUTO_PAIR_THRESHOLD = 0.75;       // Lowered from 0.82 for debug
            const POTENTIAL_MATCH_THRESHOLD = 0.45; // Lowered from 0.55 for debug
            const LEAGUE_THRESHOLD = 0.10;          // Lowered from 0.15 for debug

            for (const c of candidates) {
                // Determine if it's a match and what tier
                let matchTier: 'VERIFIED' | 'POTENTIAL' | null = null;

                if (c.teamScore >= AUTO_PAIR_THRESHOLD) {
                    matchTier = 'VERIFIED';
                } else if (c.teamScore >= POTENTIAL_MATCH_THRESHOLD) {
                    // For potential matches, we still want some league correlation or very high team score
                    if (c.teamScore >= 0.70 || c.leagueScore >= LEAGUE_THRESHOLD) {
                        matchTier = 'POTENTIAL';
                    }
                }

                if (matchTier) {
                    partner = c.other;
                    pairScore = c.teamScore;
                    const logPrefix = matchTier === 'VERIFIED' ? '[PAIRED-AUTO]' : '[PAIRED-POTENTIAL]';
                    console.log(`${logPrefix} üîó Found: ${entry.home} vs ${entry.away} <-> ${c.other.home} vs ${c.other.away} (Score: ${pairScore.toFixed(2)})`);

                    // Store the tier in the entry temporarily so it can be picked up below
                    (partner as any)._tempTier = matchTier;
                    break;
                }
            }
        }

        if (partner) {
            const tier = (partner as any)._tempTier || 'VERIFIED';
            const pairId = partner.globalId || partner.matchId; // Use A's ID as the master
            entry.globalId = pairId;

            if (!this.confirmedPairs.has(pairId)) {
                const successMsg = `[PAIR-SUCCESS] üéâ [${entry.home} vs ${entry.away}] <-> [${partner.home} vs ${partner.away}] (Score: ${pairScore.toFixed(2)}, Tier: ${tier}, GlobalID: ${pairId})`;
                console.log(successMsg);
                this.logToDisk(successMsg);

                // Ensure both IDs map to this common pairId
                this.eventLookup.get(`${account}:${entry.rawId}`)!.add(pairId);

                this.confirmedPairs.set(pairId, {
                    globalId: pairId,
                    matchA: account === 'A' ? entry : partner,
                    matchB: account === 'B' ? entry : partner,
                    score: pairScore,
                    foundAt: Date.now(),
                    lastVerifiedAt: Date.now(),
                    state: tier
                });
                this.broadcastPairing(pairId);
            } else {
                const existing = this.confirmedPairs.get(pairId)!;
                existing.lastVerifiedAt = Date.now();
                existing.score = pairScore;
                if (existing.state === 'POTENTIAL' && tier === 'VERIFIED') {
                    existing.state = 'VERIFIED';
                    console.log(`[PAIR-UPGRADE] üéñÔ∏è Upgraded ${pairId} to VERIFIED`);
                }
            }
        }
        const metricKey = `${account}:${subProvider}`;
        const metric = this.providerMetrics.get(metricKey) || { lastIngestion: 0, eventCount: 0 };
        metric.lastIngestion = Date.now();
        metric.eventCount = registry.size;
        this.providerMetrics.set(metricKey, metric);

        // [v3.2] Forensic Log for Account B Registration
        if (account === 'B' && registry.size % 10 === 0) {
            this.logToDisk(`[DISCOVERY-B] Registered: ${entry.home} vs ${entry.away} | RegistrySize=${registry.size}`);
        }
    }

    /**
     * üõ°Ô∏è v6.3 RECHECK ORPHANED MATCHES
     * Periodically tries to pair matches that haven't found a partner yet.
     */
    private async recheckOrphanedMatches() {
        const now = Date.now();
        const unpairedB = Array.from(this.registryB.values()).filter(m => {
            // Check if this B match is already in a pair
            return !Array.from(this.confirmedPairs.values()).some(p => p.matchB.matchId === m.matchId);
        });

        if (unpairedB.length > 0 && this.registryA.size > 0) {
            console.log(`[PAIR-RECHECK] üîÑ Attempting to pair ${unpairedB.length} orphaned matches...`);
            for (const entry of unpairedB) {
                // Basically re-run the pairing logic for this entry
                await this.registerMatch('B', 'RECHECK', entry);
            }
        }
    }

    private cleanTeamName(raw: string): string {
        return raw
            .replace(/\b(women)\b/gi, 'W')
            .replace(/\(women\)/gi, 'W')
            .replace(/\(w\)/gi, 'W')
            .replace(/\(u(\d+)\)/gi, 'U$1')
            .replace(/\(reserves\)/gi, 'Reserves')
            .replace(/\(\)/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    /**
     * üõ°Ô∏è v7.1 BASE/QUOTE VALIDATION
     * Validates that market types are symmetrical (e.g., Over 2.5 vs Under 2.5, not Under 2.75)
     */
    private validateMarketSymmetry(marketA: any, marketB: any): { valid: boolean; reason?: string } {
        if (!marketA || !marketB) return { valid: true }; // Allow if market info not available

        const typeA = (marketA.market || marketA.type || '').toLowerCase();
        const typeB = (marketB.market || marketB.type || '').toLowerCase();
        const lineA = parseFloat(marketA.line || marketA.handicap || '0');
        const lineB = parseFloat(marketB.line || marketB.handicap || '0');

        // Check if market types are compatible
        const isHdpA = typeA.includes('hdp') || typeA.includes('handicap') || typeA.includes('spread');
        const isHdpB = typeB.includes('hdp') || typeB.includes('handicap') || typeB.includes('spread');
        const isOuA = typeA.includes('ou') || typeA.includes('over') || typeA.includes('under') || typeA.includes('total');
        const isOuB = typeB.includes('ou') || typeB.includes('over') || typeB.includes('under') || typeB.includes('total');

        // Market types must match (HDP vs HDP, OU vs OU)
        if ((isHdpA && !isHdpB) || (isOuA && !isOuB)) {
            return { valid: false, reason: 'market_type_mismatch' };
        }

        // For OU, lines must be the same (e.g., Over 2.5 vs Under 2.5)
        if (isOuA && isOuB) {
            if (Math.abs(lineA - lineB) > 0.01) {
                return { valid: false, reason: 'ou_line_mismatch' };
            }
        }

        return { valid: true };
    }

    private isRealEvent(raw: any, account?: string): { valid: boolean, reason?: string, canonical?: { home: string, away: string } } {
        let hRaw = (raw.HomeName || raw.home || raw.h || raw.Home || raw.H || raw.ht || raw.HT || raw.HomeTeam || raw.hTeam || '').trim();
        let aRaw = (raw.AwayName || raw.away || raw.a || raw.Away || raw.A || raw.at || raw.AT || raw.AwayTeam || raw.aTeam || '').trim();

        // üõ°Ô∏è v8.8: Strip HTML tags immediately (e.g. <font>LIVE</font>)
        hRaw = hRaw.replace(/<[^>]*>/g, '').trim();
        aRaw = aRaw.replace(/<[^>]*>/g, '').trim();

        // üõ°Ô∏è v4.5 RECOVERY BYPASS: Ignore everything, return raw
        if (this.bypassAllFilters) {
            return { valid: true, canonical: { home: hRaw, away: aRaw } };
        }

        if (!hRaw || !aRaw) {
            this.logToDisk(`[DISCOVERY-REJECT] Missing team names: home="${hRaw}" away="${aRaw}"`);
            return { valid: false, reason: 'missing_teams' };
        }

        // üõ°Ô∏è v3.5.5 CSS/HTML Junk Guard (Relaxed: allow parentheses)
        if (/[{};:.\[\]]/.test(hRaw) || /[{};:.\[\]]/.test(aRaw)) {
            return { valid: false, reason: 'junk_pattern' };
        }

        const hClean = this.cleanTeamName(hRaw);
        const aClean = this.cleanTeamName(aRaw);

        if (hClean.toLowerCase() === aClean.toLowerCase()) {
            return { valid: false, reason: 'same_identity' };
        }

        // üõ°Ô∏è v4.1 DATA SANITIZATION: Strict Whitelist (Identical to Frontend)
        const isJunk = (n: string) => {
            // Only flag as junk if it contains odds-like decimals or pure date strings (e.g. 1.25, 01/12)
            // Allow numbers like "U21", "Schalke 04", "1. FC"
            const containsOdds = /\b\d+\.\d{2}\b/.test(n); // Match 1.25, etc.
            const containsDate = /\b\d{1,2}\/\d{1,2}\b/.test(n); // Match 24/01, etc.
            return containsOdds || containsDate;
        };

        // üõ°Ô∏è v7.6: Expanded Keyword Junk Filter
        const junkKeywords = [
            'slot', 'game', 'provider', 'promo', 'bonus', 'credit', 'balance', 'withdraw',
            'support', 'bantuan', 'hubungi', 'whatsapp', 'joker', 'jili', 'pg soft', 'pragmatic',
            'advantplay', 'playstar', 'octoplay', 'skywind', 'netent', 'event', 'c-sport', 'i-sport', 'b-sport', 'o-sport', 's-sport', 'w-sport',
            'live streaming', 'total score', 'full time', 'half time', 'available fund', 'bet slip', 'bet list', 'statement', 'result',
            'china odds', 'quick bet', 'dark mode', 'compact version', 'galaxy', 'my favorites', 'world cup', 'winter olympics',
            'australian open', 'nba', 'sports', 'early', 'today', 'live', 'soccer', 'odd/even', 'correct score', 'mix parlay',
            'outright', 'rebate', 'reward', 'collect', 'history', 'account', 'transaction', 'profil', 'berita', 'memo', 'unduh', 'aplikasi',
            'running', 'finished', 'cancelled', 'pending', 'waiting', 'process', 'loading', 'please wait', 'error', 'success', 'fail',
            'english', 'bahasa', 'indonesia', 'thailand', 'vietnam', 'khmer', 'korean', 'japanese', 'chinese', 'logout', 'login', 'register',
            'fishing', 'lottery', 'poker', 'casino', 'e-sports', 'virtuals', 'racing', 'table games', 'arcade', 'popular', 'new games',
            'user information', 'silver', 'gold', 'platinum', 'diamond', 'vip', 'report', 'statement', 'balance', 'deposit', 'withdraw',
            'promotion', 'referral', 'contact us', 'about us', 'faq', 'terms', 'privacy', 'rules', 'announcement', 'message',
            'basketball_ignore', 'football_ignore', 'soccer_ignore', 'tennis_ignore', 'volleyball_ignore', 'badminton_ignore', 'baseball_ignore', 'cricket_ignore', 'rugby_ignore', 'darts_ignore', 'finance', 'more',
            'mix parlay', 'step', 'level', 'handicap', 'over/under', '1x2', 'odd/even', 'total goal', 'correct score', 'half time/full time',
            'play now', 'try now', 'mahjong', 'ways', 'sugar', 'wild', 'coin', 'kong', 'maxways', 'adventure', 'monopoly', 'legend', 'empire',
            'lucky', 'vgaming', 'nolimit', 'relax', 'pragmatic', 'hacksaw', 'red tiger', 'spade'
        ];

        const isSpam = (n: string) => {
            const lower = n.toLowerCase();
            // üõ°Ô∏è v8.8: Exact word match or selective partials
            return junkKeywords.some(kw => {
                if (kw === 'live' || kw === 'today' || kw === 'early') {
                    // Exact check for these to avoid false positives in team names
                    return lower === kw || lower.startsWith(`${kw} `) || lower.endsWith(` ${kw}`) || lower.includes(` ${kw} `);
                }
                return lower.includes(kw);
            });
        };

        // üõ°Ô∏è v7.4: Loosened Multi-word Junk Check (Allow up to 10 words)
        if (hClean.split(' ').length > 10 || aClean.split(' ').length > 10) {
            return { valid: false, reason: 'too_many_words_likely_sentence' };
        }

        if (isJunk(hClean) || isJunk(aClean) || isSpam(hClean) || isSpam(aClean)) {
            // üõ°Ô∏è v8.9: FAIL-OPEN for Account B
            if (account === 'B') {
                const bConfidence = (hClean.length > 5 && aClean.length > 5) ? 80 : 40;
                if (bConfidence >= 80) {
                    this.logToDisk(`[HEURISTIC-PASS] B: Passing suspected junk due to name length: ${hClean} vs ${aClean}`);
                } else {
                    return { valid: false, reason: 'junk_pattern_detected' };
                }
            } else {
                return { valid: false, reason: 'junk_pattern_detected' };
            }
        }

        // Bypass check
        if (this.bypassAllFilters) return { valid: true, canonical: { home: hClean, away: aClean } };

        return { valid: true, canonical: { home: hClean, away: aClean } };
    }

    private broadcastPairing(globalId: string) {
        const pair = this.confirmedPairs.get(globalId);
        if (pair) this.gateway.sendUpdate('discovery:pair', pair);
    }

    private cleanRegistry() {
        // üöÄ TAHAP 3: Eliminasi "Ghost Match" (HEARTBEAT CLEANUP)
        const now = Date.now();
        let purgedA = 0;
        let purgedB = 0;

        // Clean Account A Registry
        for (const [id, entry] of this.registryA.entries()) {
            const age = now - entry.lastSeen;
            if (age > this.LOB_TTL_MS) {
                this.registryA.delete(id);
                purgedA++;
            }
        }

        // Clean Account B Registry
        for (const [id, entry] of this.registryB.entries()) {
            const age = now - entry.lastSeen;
            if (age > this.LOB_TTL_MS) {
                this.registryB.delete(id);
                purgedB++;
            }
        }

        // Clean Confirmed Pairs linked to stale matches
        for (const [pairId, pair] of this.confirmedPairs.entries()) {
            const staleA = !this.registryA.has(pair.matchA.matchId);
            const staleB = !this.registryB.has(pair.matchB.matchId);

            if (staleA || staleB) {
                this.confirmedPairs.delete(pairId);
            }
        }

        if (purgedA > 0 || purgedB > 0) {
            console.log(`[LOB-CLEANUP] üßπ Ghost Match Removed: A=${purgedA}, B=${purgedB} (Stale > ${this.LOB_TTL_MS / 1000}s)`);
        }
    }

    public cleanAccount(account: string) {
        // [v7.5] RE-ENABLED: Full account purge
        console.log(`[DISCOVERY-PURGE] üßπ Purging all matches for Account ${account}`);
        if (account === 'A') {
            this.registryA.clear();
        } else if (account === 'B') {
            this.registryB.clear();
        }
    }

    public deleteMatch(account: 'A' | 'B', matchId: string) {
        const registry = account === 'A' ? this.registryA : this.registryB;
        if (registry.delete(matchId)) {
            console.log(`[LOB-ENGINE] üóëÔ∏è Explicit DELETE for ${account}:${matchId}`);
        }
    }

    public setProviderState(account: 'A' | 'B', isLive: boolean) {
        // Mocked or implemented if needed for backward compatibility
    }

    public setBypass(active: boolean) {
        this.bypassAllFilters = active;
    }

    public getStats() {
        return {
            registryASize: this.registryA.size,
            registryBSize: this.registryB.size,
            confirmedPairs: this.confirmedPairs.size,
            marketPoolSize: this.marketPool.size
        };
    }

    private printStabilityReport() {
        const countA = this.registryA.size;
        const countB = this.registryB.size;
        const pairsCount = this.confirmedPairs.size;
        const velA = (this.updateCounts.A / 10).toFixed(1);
        const velB = (this.updateCounts.B / 10).toFixed(1);

        const report = `[STABILITY-REPORT] A: ${countA} events (${velA} up/s) | B: ${countB} events (${velB} up/s) | Pairs: ${pairsCount}`;
        console.log(report);
        this.logToDisk(report);

        // üõ°Ô∏è v3.5 Broadcast active events to dashboard
        try {
            this.gateway.sendUpdate('active_events', {
                A: countA,
                B: countB,
                pairs: pairsCount,
                velocityA: parseFloat(velA),
                velocityB: parseFloat(velB)
            });
        } catch (e) { }

        // üõ°Ô∏è v3.5 Production Ready Log
        const executionGuard = (countA > 0 && countB > 0) ? 'READY' : 'BLOCKED';
        const prodLog = `[PRODUCTION-READY] Pairs: ${pairsCount} | Execution Guard: ${executionGuard}`;
        console.log(prodLog);
        this.logToDisk(prodLog);

        if (countB > 50) {
            const flowMsg = `[STABILITY-REPORT] üåä ISPORT data flow is heavy (${countB} events). Iframe is flowing!`;
            console.log(flowMsg);
            this.logToDisk(flowMsg);
        }

        // üõ°Ô∏è v5.2 SCANNER PRIORITY CHECK
        this.checkScannerPriority(countB);

        // üõ°Ô∏è v5.2 PASSIVE OBSERVER MODE - No auto-navigation
        const isPassiveMode = Date.now() < this.PASSIVE_MODE_UNTIL;

        // üõ°Ô∏è v4.0 AUTO-REFRESH LOGIC (DISABLED IN PASSIVE MODE)
        if (countB < 5) {
            this.lowEventsBCounter++;

            // üõ°Ô∏è v4.1 DATA PULSE: Alert dashboard every 20s if low
            if (this.lowEventsBCounter % 2 === 0) {
                this.gateway.sendUpdate('system_log', {
                    level: 'warn',
                    message: `[SENSOR-B-LOW] Events B < 5 (${countB}). ${isPassiveMode ? 'Passive Mode - Please navigate manually.' : 'Re-check ISPORT tab navigation.'}`
                });
            }

            // üõ°Ô∏è v5.2 PASSIVE MODE: NO AUTO-CLICK
            if (this.lowEventsBCounter >= 6 && !isPassiveMode) { // 6 * 10s = 60s
                this.logger.warn('‚ö†Ô∏è [AUTO-REFRESH] Events B < 5 for 60s. Forcing "Football" navigation via command.');
                this.gateway.emitBrowserCommand('B', 'CLICK_FOOTBALL');
                this.lowEventsBCounter = 0; // Reset after trigger
            } else if (isPassiveMode && this.lowEventsBCounter >= 6) {
                this.logger.warn('‚è∏Ô∏è [PASSIVE-MODE] Auto-navigation BLOCKED. Waiting for manual navigation on Account B.');
                this.gateway.sendUpdate('system_log', {
                    level: 'info',
                    message: '‚è∏Ô∏è PASSIVE MODE: Auto-navigation disabled. Please navigate to Soccer manually in Account B browser.'
                });
                this.lowEventsBCounter = 0;
            }
        } else {
            this.lowEventsBCounter = 0; // Clear counter if data returns
        }

        // Reset counts for next 10s window
        this.updateCounts.A = 0;
        this.updateCounts.B = 0;
    }

    private logToDisk(msg: string) {
        try {
            const logDir = path.join(process.cwd(), 'logs');
            if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true });
            const logPath = path.join(logDir, 'wire_debug.log');
            fs.appendFileSync(logPath, `[${new Date().toISOString()}] ${msg}\n`);
        } catch (e) { }
    }
}
